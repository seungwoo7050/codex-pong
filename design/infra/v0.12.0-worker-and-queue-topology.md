# v0.12.0 워커/큐 토폴로지 설계

## 1. 목적
- 리플레이 내보내기 잡을 메인 백엔드와 분리된 **replay-worker** 프로세스에서 처리해 안정성을 높인다.
- Redis Streams 기반 큐 토폴로지를 정의해 요청/진행률/결과를 신뢰성 있게 전달한다.
- Docker Compose 수준에서 필요한 환경변수, 볼륨, 네트워크 구성을 고정한다.

## 2. 범위
- Redis Streams 선택(단일 큐 메커니즘)과 스트림 키 명세.
- `replay-worker` 서비스 구성(Dockerfile, ffmpeg CLI 포함).
- 백엔드/워커가 공유하는 스토리지/네트워크/환경변수.
- 최소 재시도 및 데드레터 정책.

## 3. 토폴로지
### 3.1 스트림/컨슈머 그룹
- 요청 스트림: `job.requests`
  - 프로듀서: 백엔드 `JobQueuePublisher`.
  - 컨슈머: `replay-worker`(단일 워커 혹은 여러 워커가 동일 그룹으로 묶여 각 메시지를 1회 소비).
- 진행률 스트림: `job.progress`
  - 프로듀서: 워커.
  - 컨슈머: 백엔드 `JobQueueListener` → `JobService`.
- 결과 스트림: `job.results`
  - 프로듀서: 워커.
  - 컨슈머: 백엔드 `JobQueueListener`.
- 컨슈머 그룹: `replay-jobs`를 모든 스트림에서 사용해 추적/ACK 일관성을 맞춘다.
- 데드레터 스트림: `job.deadletter`(백엔드가 처리 실패 레코드를 이동). 운영자가 필요 시 재발행한다.

### 3.2 메시지 스키마 (고정)
- 요청: `{ jobId, jobType, replayId, options }` (`options`에 `inputPath`, `outputPath`, `durationMs`, `ownerId`, `createdAt`).
- 진행률: `{ jobId, progress, phase, message }`.
- 결과: `{ jobId, status, resultUri, checksum, errorCode, errorMessage }`.

## 4. 서비스 구성
### 4.1 Docker Compose
- `redis`: `redis:7-alpine`, `appendonly no`, 포트 `6379` 노출.
- `backend`: `REDIS_HOST`, `JOB_QUEUE_*` 환경변수 설정, `/data/replays` 볼륨 마운트.
- `replay-worker`:
  - `worker/Dockerfile` 기반 Python 이미지에 **ffmpeg CLI** 설치.
  - 환경변수: `REDIS_HOST`, `JOB_QUEUE_REQUEST_STREAM`, `JOB_QUEUE_PROGRESS_STREAM`, `JOB_QUEUE_RESULT_STREAM`, `JOB_QUEUE_CONSUMER_GROUP`, `WORKER_ID`.
  - 볼륨: `/data/replays`(백엔드와 공유)로 결과 파일을 동일 경로에 저장.
  - 재시작 정책: `unless-stopped`로 백엔드와 격리.

### 4.2 네트워크/스토리지
- 모든 서비스가 Docker 기본 브리지 네트워크를 공유, 스트림 키는 네임스페이스 없이 단일 Redis 인스턴스를 사용.
- 리플레이/내보내기 산출물은 `replay_data` 볼륨(`/data/replays`)에 저장해 백엔드 `resultUri`와 워커 출력 경로가 일치하도록 한다.

## 5. 워커 동작
- `worker/main.py`가 `job.requests`를 블록킹 소비 → FFmpeg CLI 실행:
  - MP4: `ffmpeg -y -i <input> ... <output>.mp4` (테스트 기본색 화면).
  - 썸네일: `ffmpeg -y -i <input> -frames:v 1 <output>.png`.
- `-progress pipe:1` 출력 또는 단계 기반으로 `progress/phase/message`를 주기적으로 발행.
- 성공 시 `resultUri`와 SHA-256 체크섬을 포함한 결과 메시지를 전송, 실패 시 `errorCode/errorMessage`를 채운다.
- 워커 장애 시 큐 메시지는 컨슈머 그룹에서 미처리 상태로 남고, 워커 재시작 후 처리된다(백엔드 프로듀서는 재발행하지 않는다).

## 6. 재시도/멱등성 정책
- 백엔드: 동일 jobId 중복 생성 방지, 터미널 상태 이후 이벤트 무시, 처리 실패 레코드는 `job.deadletter`로 이동 후 ACK.
- 워커: 동일 jobId 메시지를 재처리하더라도 `outputPath` 기준으로 덮어쓰기 없이 성공/실패를 단일 레코드로 발행해야 한다.
- 운영 재시도: deadletter를 검사해 필요 시 동일 메시지를 `job.requests`로 다시 발행(멱등성 유지).

## 7. 운영 메모
- Redis/ffmpeg 사용량 모니터링을 위해 Prometheus에 큐 길이/워커 처리 시간 메트릭을 추후 추가할 수 있도록 여지를 둔다.
- 로컬 실행 시 ffmpeg가 설치되어 있어야 하며, `JOB_QUEUE_ENABLED=false`로 백엔드를 구동하면 잡 큐 소비를 비활성화할 수 있다(테스트용).
